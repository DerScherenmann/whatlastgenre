#!/usr/bin/env python

from __future__ import division
from collections import namedtuple
from difflib import get_close_matches
import ConfigParser
import argparse
import difflib
import glob
import json
import musicbrainzngs
import mutagen
import operator
import os
import re
import requests
import string
import sys

# score multipliers
sm_whatcd = 1.5
sm_lastfm = 0.8
sm_mbrain = 1.0 
sm_discog = 1.0


TAlbumInfo = namedtuple('AlbumInfo', 'artist, album, va')
def AlbumInfo(artist, album, va=False):
    return TAlbumInfo(artist, album, va)

class GenreTags:
    def __init__(self):
        self.tags = {}
        # add some basic genre tags (id3)
        id3genres = ["Blues", "Classic Rock", "Country", "Dance", "Disco", "Funk", "Grunge", "Hip-Hop", "Jazz",
                     "Metal", "New Age", "Oldies", "Other", "Pop", "R&B", "Rap", "Reggae", "Rock", "Techno",
                     "Industrial", "Alternative", "Ska", "Death Metal", "Pranks", "Soundtrack", "Euro-Techno",
                     "Ambient", "Trip-Hop", "Vocal", "Jazz+Funk", "Fusion", "Trance", "Classical", "Instrumental",
                     "Acid", "House", "Game", "Sound Clip", "Gospel", "Noise", "Alternative Rock", "Bass", "Soul",
                     "Punk", "Space", "Meditative", "Instrumental Rock", "Ethnic", "Gothic", "Darkwave",
                     "Techno-Industrial", "Electronic", "Pop-Folk", "Eurodance", "Dream", "Southern Rock",
                     "Comedy", "Cult", "Gangsta", "Top 40", "Christian Rap", "Pop/Funk", "Jungle", "Native US",
                     "Cabaret", "New Wave", "Psychedelic", "Rave", "Showtunes", "Trailer", "Lo-Fi", "Tribal",
                     "Acid Punk", "Acid Jazz", "Polka", "Retro", "Musical", "Rock & Roll", "Hard Rock", "Folk",
                     "Folk-Rock", "National Folk", "Swing", "Fast Fusion", "Bebob", "Latin", "Revival", "Celtic",
                     "Bluegrass", "Avantgarde", "Gothic Rock", "Progressive Rock", "Psychedelic Rock", "Slow Rock",
                     "Symphonic Rock", "Big Band", "Chorus", "Easy Listening", "Acoustic", "Humour", "Speech",
                     "Chanson", "Opera", "Chamber Music", "Sonata", "Symphony", "Booty Bass", "Primus", "Porn Groove",
                     "Satire", "Slow Jam", "Club", "Tango", "Samba", "Folklore", "Ballad", "Power Ballad",
                     "Rhythmic Soul", "Freestyle", "Duet", "Punk Rock", "Drum Solo", "Acapella", "Euro-House",
                     "Dance Hall", "Goa", "Drum & Bass", "Club - House", "Hardcore", "Terror", "Indie", "BritPop",
                     "Negerpunk", "Polsk Punk", "Beat", "Christian Gangsta Rap", "Heavy Metal", "Black Metal",
                     "Crossover", "Contemporary Christian", "Christian Rock", "Merengue", "Salsa", "Thrash Metal",
                     "Anime", "JapanPop", "Synthpop"]
        for tag in id3genres:
            self.add(tag, 0.0)
        # TODO: add more
        tags = ["German", "German Hip-Hop", "Chillout", "Downtempo", "Jazz-Hop", "Female Vocalist", "Future Jazz", "Tech-House"]
        for tag in tags:
            self.add(tag, 0.1)
        for tag in conf.genre_score_up:
            self.add(tag, 0.2)
        for tag in conf.genre_score_down:
            self.add(tag, -0.2)

    def add(self, name, score):
        name = string.replace(name.lower(), 'prog ', 'progressive ')
        name = string.capwords(name)
        found = get_close_matches(name, self.tags.keys(), 1, 0.857)
        if found:
            if args.verbose and name.lower() != found[0].lower():
                print "%s is the same tag as %s" % (name, found[0]) 
            self.tags[found[0]] = self.tags[found[0]] + score;
        else:
            self.tags.update({name: score})

    def get(self):
        # only good ones
        tags = dict((name, score) for name, score in self.tags.iteritems() if score > 0.5)
        if args.verbose:
            print "Good tags: ",
            for key, value in sorted(tags.iteritems(), key=lambda (k, v): (v, k), reverse=True):
                print "%s: %.2f, " % (key, value),
            print
        # get sorted list from it
        tags = sorted(tags, key=self.tags.get, reverse=True)
        # filter them
        tags = self.filter_taglist(tags);
        tags = self.format_taglist(tags);
        return tags

    def filter_taglist(self, tags):
        # remove year based tags
        tags = list(tag for tag in tags if re.match('\([0-9]{2}\){1,2}s?', tag) is None)
        # remove too long tags
        tags = list(tag for tag in tags if len(tag) < 20)
        # apply whitelist
        if conf.genre_whitelist:
            wl = conf.genre_whitelist
            tags = (tag for tag in tags if tag in wl)
        # or apply blacklist
        elif conf.genre_blacklist:
            bl = conf.genre_blacklist
            tags = (tag for tag in tags if tag not in bl)
        # reduce size to limit
        tags = list(tags)[:args.tag_limit]
        return tags
    
    def format_taglist(self, tags):
        for i in range(len(tags)):
            if tags[i] in conf.genre_uppercase:
                tags[i] = string.upper(tags[i])
            elif tags[i].find("-") != -1:
                tags[i] = string.capwords(tags[i], "-")
            elif tags[i].find("/") != -1:
                tags[i] = string.capwords(tags[i], "/")
            else:
                tags[i] = string.capwords(tags[i])
        return tags



def read_folder(path):
    try:
        for thefile in os.listdir(path):
            thefile = os.path.join(path, thefile)
            if os.path.isdir(thefile):
                read_folder(thefile)
            elif os.path.splitext(thefile)[1].lower() in [".flac", ".ogg", ".mp3"]:
                handle_album(path, os.path.splitext(thefile)[1]);
                print
                break;
    except OSError, e:
        print e


def handle_album(path, filetype):
    
    tracks = glob.glob(os.path.join(path, '*' + filetype)) 
    
    print "%s-album in %s (%d tracks)..." % (filetype[1:], path, len(tracks))
    
    ai = get_album_info(tracks)
    if not ai:
        print "Warning: Not all Tracks in this folder have same album-tag. Skipping for safety..."
        return
    
    genreTags, releaseType = get_data(ai)
    
    if args.tag_release and releaseType:
        print "Release type: %s" % releaseType
    if genreTags:
        print "Genre tags: %s" % liststr(genreTags)
    
    if args.dry_run:
        print "DRY-Mode! Skipping saving of metadata..."
        return

    print "Saving metadata..."
    for track in tracks:
        set_meta(track, genreTags, releaseType)


def get_album_info(tracks):
    va = False
    try:
        meta = get_meta(tracks[0])
        #if args.verbose: print meta.pprint()
        for track in tracks:
            meta2 = get_meta(track)
            if not meta2:
                return False
            if meta['album'][0] != meta2['album'][0]:
                return False
            if meta['artist'][0] != meta2['artist'][0]:
                va = True
    except Exception, e:
        print e

    return AlbumInfo(meta['artist'][0] if not va else "", meta['album'][0], va)


def get_meta(track):
    try:
        return mutagen.File(track, easy=True)
    except Exception, e:
        print e
    return False


def set_meta(track, genreTags, releaseType):
    try:
        meta = mutagen.File(track, easy=True)
    except Exception, e:
        print e

    if args.tag_release and releaseType and os.path.splitext(track)[1].lower() in ['.flac', '.ogg']:
        meta['release'] = releaseType
    
    if genreTags:
        meta['genre'] = genreTags

    meta.save()


def get_data(ai):
    print "Getting data for \"%s - %s\"..." % (('VA' if ai.va else ai.artist), ai.album)
    genretags = GenreTags()
    releaseType = None
    mbrainzids = None
    
    if not args.no_lastfm:
        if args.verbose: print "Last.FM..."
        genretags = get_data_lastfm(ai, genretags)
    if not args.no_whatcd:
        if args.verbose: print "What.CD..."
        genretags, releaseType = get_data_whatcd(ai, genretags);
    if not args.no_mbrainz:
        if args.verbose: print "MusicBrainz..."
        genretags, mbrainzids = get_data_mbrainz(ai, genretags);
    if not args.no_discogs:
        if args.verbose: print "Discogs..."
        genretags = get_data_discogs(ai, genretags);

    return genretags.get(), releaseType


def get_data_whatcd(ai, genretags):
    
    def query(action, **args):
        params = {'action': action}
        params.update(args)
        r = session.get('https://what.cd/ajax.php', params=params)
        try:
            j = json.loads(r.content)
            if j['status'] != 'success':
                raise Exception
            return j['response']
        except:
            raise Exception
        
    def add_tags(genretags, tags):
        badtags = ['staff.picks', 'freely.available', 'vanity.house']
        tags = list(tags)
        topcount = int(tags[0]['count']) + 1
        for tag in tags:
            if tag['name'] not in badtags:
                score = int(tag['count']) / topcount * sm_whatcd
                if score > 0.01:
                    genretags.add(string.replace(tag['name'], '.', ' '), score)
        return genretags
    
    def interactive(data):
        print "Multiple releases found on What.CD, please choose the right one (0 to skip):"
        for i in range(len(data)):
            print "#%d: %s - %s [%d] [%s]" % (i + 1, data[i]['artist'], data[i]['groupName'], data[i]['groupYear'], data[i]['releaseType'])
        while True:
            try:
                c = int(raw_input("Choose Release #: "))
            except:
                c = None
            if c in range(len(data) + 1):
                break
        return None if c == 0 else data[c - 1]
    
    releaseType = None
    
    try:
        if not ai.va:
            data = query('artist', id=0, artistname=ai.artist)
            if data.has_key('tags'):
                tags = sorted(data['tags'], key=operator.itemgetter('count'), reverse=True)
                genretags = add_tags(genretags, tags)
        
        data = query('browse', searchstr=(ai.album if ai.va else ai.artist + ' ' + ai.album), **{'filter_cat[1]':1})['results']
        
        if len(data) > 1 and args.interactive:
            data = interactive(data)
        elif len(data) == 1:
            data = data[0]
        else:
            data = None
            
        if data:
            tags = []
            for tag in data['tags']:
                tags.append({'name': tag, 'count': 1 / len(data['tags'])})
            genretags = add_tags(genretags, tags)
            releaseType = data['releaseType']

    except Exception, e:
        print "ERROR with What.CD!", e

    return genretags, releaseType


def get_data_lastfm(ai, genretags):
    
    def query(method, **args):
        params = {'api_key': conf.lastfm_apikey, 'format': 'json', 'method': method}
        params.update(args)
        r = session.get('http://ws.audioscrobbler.com/2.0/', params=params) 
        try:
            j = json.loads(r.content)
            return j
        except:
            raise Exception
     
    def add_tags(genretags, tags):
        badtags = [ai.album.lower(), ai.artist.lower(), 'albums i dont own yet', 'albums i own',
                   'albums i want', 'favorite album', 'favorite', 'lieblingssongs', 'own it',
                   'owned cds', 'seen live', 'wishlist', 'best of']
        if tags.__class__ is not list:
            tags = [tags]
        topcount = int(tags[0]['count']) + 1
        for tag in tags:
            if not get_close_matches(tag['name'].lower(), badtags, 1):
                score = int(tag['count']) / topcount * sm_lastfm
                if score > 0.01:
                    genretags.add(tag['name'], score)
        return genretags
    
    try:
        if not ai.va:
            data = query('artist.gettoptags', artist=ai.artist)
            if data.has_key('toptags') and data['toptags'].has_key('tag'):
                genretags = add_tags(genretags, data['toptags']['tag'])
        
        data = query('album.gettoptags', artist='Various Artists' if ai.va else ai.artist, album=ai.album)
        if data.has_key('toptags') and data['toptags'].has_key('tag'):
            genretags = add_tags(genretags, data['toptags']['tag'])
            
    except Exception, e:
        print "ERROR with Last.FM!", e
    
    return genretags;


def get_data_mbrainz(ai, genretags):
    
    def add_tags(genretags, tags):
        tags = list(tags)
        topcount = int(tags[0]['count']) + 1
        for tag in tags:
            score = int(tag['count']) / topcount * sm_mbrain
            if score > 0.01:
                genretags.add(tag['name'], score)
        return genretags

    mbrainzids = [None, None, []]

    if not ai.va:
        r = musicbrainzngs.search_artists(artist=ai.artist, limit=1)
        if r['artist-list']:
            artistid = r['artist-list'][0]['id']
            r = musicbrainzngs.get_artist_by_id(artistid, includes=['tags'])
            if r['artist'].has_key('tag-list'):
                tags = sorted(r['artist']['tag-list'], key=operator.itemgetter('count'), reverse=True)[:(args.tag_limit * 2)]
                genretags = add_tags(genretags, tags)
                
        r = musicbrainzngs.search_release_groups(artist=ai.artist, release=ai.album, limit=1)
    if ai.va:
        r = musicbrainzngs.search_release_groups(release=ai.album, limit=1)
        
    if r['release-group-list']:
        releasegroupid = r['release-group-list'][0]['id']
        r = musicbrainzngs.get_release_group_by_id(releasegroupid, includes=['tags'])
        if r['release-group'].has_key('tag-list'):
            tags = sorted(r['release-group']['tag-list'], key=operator.itemgetter('count'), reverse=True)[:(args.tag_limit * 2)]
            genretags = add_tags(genretags, tags)
            
    try:
        pass
    except:
        print "ERROR with MusicBrainz!"

    return genretags, mbrainzids


def get_data_discogs(ai, genretags):
    
    def query(type, **args):
        params = {'type': type}
        params.update(args)
        r = session.get('http://api.discogs.com/database/search', params=params) 
        try:
            j = json.loads(r.content)
            return j['results']
        except:
            raise Exception
     
    def add_tags(genretags, tags):
        for tag in tags:
            genretags.add(tag, 1 / len(tags) * sm_discog)
        return genretags
    
    try:
        data = query('master', release_title=ai.album)
        if data:
            if data[0].has_key('style'):
                genretags = add_tags(genretags, data[0]['style'])
            if data[0].has_key('genre'):
                genretags = add_tags(genretags, data[0]['genre'])
    except Exception, e:
        print "ERROR with Discogs!", e
    
    return genretags;


def liststr(mylist):
    return '%s' % ', '.join(map(str, mylist))


def searchstr(mystr):
    return re.sub(r'\[\W\S\]+', '', mystr)


def config_list(s):
    if s:
        return [i.strip() for i in s.split(',')]
    return []


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                     description='Improves genre-metadata of audio-files based on tags from various music-sites.')
    parser.add_argument('path', nargs='+',
                        help='folder(s) to scan')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='run verbose (more output)')
    parser.add_argument('-n', '--dry-run', action='store_true',
                        help='dry-run (write nothing)')
    parser.add_argument('-i', '--interactive', action='store_true',
                        help='interactive mode')
    
    parser.add_argument('-l', '--tag-limit', metavar='N', type=int,
                        help='max. number of genre tags', default=6)
    parser.add_argument('-r', '--tag-release', action='store_true',
                        help='tag release type from whatcd')

    parser.add_argument('--no-whatcd', action='store_true',
                        help='disable lookup on What.CD')
    parser.add_argument('--no-lastfm', action='store_true',
                        help='disable lookup on Last.FM')
    parser.add_argument('--no-mbrainz', action='store_true',
                        help='disable lookup on MusicBrainz')
    parser.add_argument('--no-discogs', action='store_true',
                        help='disable lookup on Discogs')

    parser.add_argument('--config', default=os.path.expanduser('~/.whatlastgenre/config'),
                        help='location of the configuration file')
    '''
    parser.add_argument('--cache', default=os.path.expanduser('~/.whatlastgenre/cache'),
                        help='location of the cache')
    parser.add_argument('--no-cache', action='store_true',
                        help='disable cache feature')
    parser.add_argument('--clear-cache', action='store_true',
                        help='clear the cache')
    '''

    global args
    args = parser.parse_args()
    
    if args.no_whatcd and args.no_lastfm and args.no_mbrainz and args.no_discogs:
        print "Where do you want to get your data from? At least one source must be activated!"
        sys.exit()

    config = ConfigParser.SafeConfigParser()
    try:
        open(args.config)
        config.read(args.config)
    except:
        if not os.path.exists(os.path.dirname(args.config)):
            os.makedirs(os.path.dirname(args.config))
        config.add_section('whatcd')
        config.set('whatcd', 'username', '')
        config.set('whatcd', 'password', '')
        config.add_section('lastfm')
        config.set('lastfm', 'apikey', '54bee5593b60d0a5bf379cedcad79052')
        config.add_section('genres')
        config.set('genres', 'whitelist', '')
        config.set('genres', 'blacklist', '')
        config.set('genres', 'uppercase', 'IDM, UK')
        config.set('genres', 'score_up', 'Trip-Hop')
        config.set('genres', 'score_down', 'Electronic, Rock, Metal, Alternative, Indie, Other, Other, Unknown, Unknown')
        config.write(open(args.config, 'w'))
        print "Please edit the configuration file: %s" % args.config
        sys.exit(2)

    global conf
    conf = namedtuple('conf', '')
    conf.genre_whitelist = config_list(config.get('genres', 'whitelist'))
    conf.genre_blacklist = config_list(config.get('genres', 'blacklist'))
    conf.genre_uppercase = config_list(config.get('genres', 'uppercase'))
    conf.genre_score_up = config_list(config.get('genres', 'score_up'))
    conf.genre_score_down = config_list(config.get('genres', 'score_down'))
    conf.lastfm_apikey = config.get('lastfm', 'apikey')
    
    global session
    session = requests.session()
    if not args.no_whatcd:
        session.post('https://what.cd/login.php', {'username': config.get('whatcd', 'username'),
                                                   'password': config.get('whatcd', 'password')})
    if not args.no_mbrainz:
        musicbrainzngs.set_useragent("genrefixer", "0.1")
    
    ''' DEVEL Helper '''
    #args.verbose = True
    #args.dry_run = True
    #args.tag_release = True
    #args.interactive = True
    #args.path.append('/home/foo/nobackup/test/')
    #args.path.append('/media/music/Alben/Boards of Canada')
    #import random; args.path.append(os.path.join('/media/music/Alben', random.choice(os.listdir('/media/music/Alben'))))
    
    for path in args.path:
        read_folder(path)
        
    print "... all done!"

if __name__ == "__main__":
    main()
